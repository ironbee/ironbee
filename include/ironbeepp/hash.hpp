/*****************************************************************************
 * Licensed to Qualys, Inc. (QUALYS) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * QUALYS licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ****************************************************************************/

/**
 * @file
 * @brief IronBee++ --- Hash
 *
 * This file defines (Const)Hash, a wrapper for ib_hash_t.
 *
 * @remark Developers should be familiar with @ref ironbeepp to understand
 * aspects of this code, e.g., the public/non-virtual inheritance.
 *
 * @author Christopher Alfeld <calfeld@qualys.com>
 */

#ifndef __IBPP__HASH__
#define __IBPP__HASH__

#include <ironbeepp/abi_compatibility.hpp>
#include <ironbeepp/byte_string.hpp>
#include <ironbeepp/common_semantics.hpp>
#include <ironbeepp/c_trampoline.hpp>
#include <ironbeepp/exception.hpp>
#include <ironbeepp/list.hpp>
#include <ironbeepp/memory_manager.hpp>
#include <ironbeepp/throw.hpp>

#include <ironbee/hash.h>

#include <boost/bind.hpp>
#include <boost/iterator/iterator_facade.hpp>
#include <boost/type_traits/is_pointer.hpp>
#include <boost/utility/enable_if.hpp>

#include <ostream>

namespace IronBee {

/// @cond Internal
namespace Internal {

/**
 * Iterate through an ib_hash_t, casting values to pointers.
 *
 * This template implements non-mutable forward iterators for ib_hash_t,
 * where the values are cast to a pointer type, @a T, via reinterpret_cast
 * (contrast to hash_const_iterator).
 *
 * It is generated by Hash and ConstHash when their value type is a pointer.
 *
 * Note that the reference type for this iterator is not a reference.
 *
 * @sa hash_const_iterator
 * @sa Hash
 * @sa ConstHash
 *
 * @tparam T Value to cast @c void* hash value to.
 **/
template <typename T>
class pointer_hash_const_iterator :
    public boost::iterator_facade<
        pointer_hash_const_iterator<T>,
        std::pair<std::pair<const char*, size_t>, T>,
        boost::forward_traversal_tag,
        std::pair<std::pair<const char*, size_t>, T>
    >
{
public:
    //! Construct from ib_hash_iterator_t
    explicit
    pointer_hash_const_iterator(ib_hash_iterator_t* ib_iter) :
        m_iter(ib_hash_iterator_create_malloc()),
        m_at_end(false)
    {
        ib_hash_iterator_copy(m_iter, ib_iter);
    }

    //! Construct from ib_hash_t.  Beginning.
    explicit
    pointer_hash_const_iterator(const ib_hash_t* h) :
        m_iter(ib_hash_iterator_create_malloc()),
        m_at_end(false)
    {
        ib_hash_iterator_first(m_iter, h);
    }

    //! Default constructor; end iterator.
    pointer_hash_const_iterator() :
        m_iter(ib_hash_iterator_create_malloc()),
        m_at_end(true)
    {
        // nop
    }

    //! Copy constructor.
    pointer_hash_const_iterator(const pointer_hash_const_iterator& other) :
        m_iter(ib_hash_iterator_create_malloc()),
        m_at_end(other.m_at_end)
    {
        ib_hash_iterator_copy(m_iter, other.m_iter);
    }

    //! Destructor.
    ~pointer_hash_const_iterator()
    {
        free(m_iter);
    }

    //! Provide underlying ib_hash_iterator_t.
    ib_hash_iterator_t* iterator() const
    {
        return m_iter;
    }

private:
    friend class boost::iterator_core_access;

    //! Increment iterator.
    void increment()
    {
        if (! m_at_end && ! ib_hash_iterator_at_end(m_iter)) {
            ib_hash_iterator_next(m_iter);
        }
    }

    //! Compare iterators.
    bool equal(
        const pointer_hash_const_iterator& other
    ) const
    {
        bool me_at_end =
            m_at_end || ib_hash_iterator_at_end(m_iter);
        bool other_at_end =
            other.m_at_end || ib_hash_iterator_at_end(other.m_iter);
        if (me_at_end || other_at_end) {
            return me_at_end && other_at_end;
        }
        return ib_hash_iterator_equal(m_iter, other.m_iter);
    }

    //! Dereference iterator.  Note return of copy.
    std::pair<std::pair<const char*, size_t>, T> dereference() const
    {
        const char* key;
        size_t key_length;
        void* value;

        ib_hash_iterator_fetch(&key, &key_length, &value, m_iter);
        return std::make_pair(
            std::make_pair(key, key_length),
            reinterpret_cast<T>(value)
        );
    }

    //! Our very own iterator.
    ib_hash_iterator_t* m_iter;
    //! True if we are an explicit end iterator.
    bool m_at_end;
};

/**
 * Iterate through an ib_hash_t, casting values to IronBee++ objects.
 *
 * This template implements non-mutable forward iterators for ib_hash_t,
 * where the values are converted to IronBee++ objects.  Recall that IronBee++
 * objects behave much like pointers.
 *
 * It is generated by Hash and ConstHash when their value type is not a
 * pointer.
 *
 * Note that the reference type for this iterator is not a reference.
 *
 * @sa pointer_hash_const_iterator
 * @sa Hash
 * @sa ConstHash
 *
 * @remark This template is adapted from pointer_hash_iterator<T::ib_type>.
 *
 * @tparam T Value to convert hash value to.  Must define @c ib_type member
 *           typedef and a constructor from @c ib_type.
 **/
template <typename T>
class hash_const_iterator :
    public boost::iterator_adaptor<
        hash_const_iterator<T>,
        pointer_hash_const_iterator<typename T::ib_type>,
        std::pair<std::pair<const char *, size_t>, T>,
        boost::bidirectional_traversal_tag,
        std::pair<std::pair<const char *, size_t>, T> // Note: Not reference.
    >
{
public:
    //! Default constructor; all operations except assignment undefined.
    hash_const_iterator()
    {
        // nop
    }

    //! Construct from ib_hash_iterator_t.
    explicit
    hash_const_iterator(
        ib_hash_iterator_t* i
    )  :
        hash_const_iterator::iterator_adaptor_(
            pointer_hash_const_iterator<typename T::ib_type>(i)
        )
    {
        // nop
    }

    //! Construct from hash.
    explicit
    hash_const_iterator(
        const ib_hash_t* h
    ) :
        hash_const_iterator::iterator_adaptor_(
            pointer_hash_const_iterator<typename T::ib_type>(h)
        )
    {
        // nop
    }

    //! Copy constructor.
    hash_const_iterator(
        const hash_const_iterator& other
    ) :
        hash_const_iterator::iterator_adaptor_(other.base())
    {
        // nop
    }

    //! Provide underlying ib_hash_iterator_t.
    ib_hash_iterator_t* iterator() const
    {
        return this->base().node();
    }

    //! Operator-> support.
    std::pair<std::pair<const char *, size_t>, T>* operator->() const
    {
        typedef std::pair<std::pair<const char *, size_t>, T>  value_t;
        static value_t m_dummy;
        base_value_t base = *this->base();
        m_dummy.first = base.first;
        m_dummy.second = T(base.second);
        return &m_dummy;
    }

private:
    friend class boost::iterator_core_access;

    typedef typename pointer_hash_const_iterator<
        typename T::ib_type
    >::value_type base_value_t;

    //! Dereference.  Note returns copy not reference.
    T dereference() const
    {
        base_value_t base = *this->base();
        return std::make_pair(base.first, T(base.second));
    }
};

/**
 * Metafunction to calculate appropriate iterator type.
 *
 * If @a T is a pointer then pointer_hash_const_iterator is used, otherwise
 * hash_const_iterator is used.
 *
 * @tparam T Desired value type of iterator.
 **/
template <typename T>
struct make_hash_const_iterator
{
    typedef hash_const_iterator<T> type;
};

//! Overload of previous to make it work for pointers.
template <typename Base>
struct make_hash_const_iterator<Base*>
{
    typedef pointer_hash_const_iterator<Base*> type;
};

/**
 * Converts pointers to themselves or IronBee objects appropriately.
 **/
template <typename T>
void void_as_value(T& to, void* v, boost::true_type)
{
    to = reinterpret_cast<T>(v);
}

//! Overload of previous.
template <typename T>
void void_as_value(T& to, void* v, boost::false_type)
{
    to = T(reinterpret_cast<typename T::ib_type>(v));
}

} // Internal
/// @endcond

template <typename T>
class ConstHash;

template <typename T>
class Hash;

/**
 * Metafunction to determine if @a T is a ConstHash or Hash.
 *
 * Inherits from true_type if @a T is a ConstHash or Hash and false_type
 * otherwise.
 *
 * @tparam T Type to test.
 **/
template <typename T>
struct is_hash : public boost::false_type {};
//! Implementation detail of is_hash.
template <typename U>
struct is_hash<ConstHash<U> > : public boost::true_type {};
//! Implementation detail of is_hash.
template <typename U>
struct is_hash<Hash<U> > : public boost::true_type {};

/**
 * Const Hash; equivalent to a const pointer to ib_hash_t.
 *
 * Provides operators ==, !=, <, >, <=, >= and evaluation as a boolean for
 * singularity via CommonSemantics.
 *
 * See Hash for discussion of hashes
 *
 * @tparam T Value type for hash.
 *
 * @sa Hash
 * @sa ironbeepp
 * @sa ib_hash_t
 * @nosubgrouping
 **/
template <typename T>
class ConstHash :
    public CommonSemantics<ConstHash<T> >
{
public:
    //! C Type.
    typedef const ib_hash_t* ib_type;

    /**
     * Construct singular ConstHash.
     *
     * All behavior of a singular ConstHash is undefined except for
     * assignment, copying, comparison, and evaluate-as-bool.
     **/
    ConstHash() :
        m_ib(NULL)
    {
        // nop
    }

    /**
     * @name C Interoperability
     * Methods to access underlying C types.
     **/
    ///@{

    //! const ib_hash_t accessor.
    // Intentionally inlined.
    ib_type ib() const
    {
        return m_ib;
    }

    //! Construct Hash from ib_hash_t.
    explicit
    ConstHash(ib_type ib_hash) :
        m_ib(ib_hash)
    {
        // nop
    }

    ///@}

    /**
     * @name STL types.
     *
     * These typedefs provide useful information and compatibility with STL
     * oriented code.
     *
     * Note that iterator and const_iterator are identical (similar to
     * std::set) and that reference is the same as value_type (i.e., iterators
     * dereference to copy).
     *
     * In addition to the usual iterator operations, all iterators provide an
     * iterator() method that returns the underlying @c ib_hash_iterator_t* or
     * NULL for iterators that do not refer to actual entries, e.g., end().
     **/
    ///@{
    //! Iterator; forward input iterator.
    typedef typename Internal::make_hash_const_iterator<T>::type iterator;
    //! Const iterator; same as iterator.
    typedef iterator const_iterator;
    //! Reference; same as value_type.
    typedef typename iterator::reference reference;
    //! Const reference; same as reference, i.e., value_type.
    typedef reference const_reference;
    //! Size type.
    typedef size_t size_type;
    //! Different type.
    typedef typename iterator::difference_type difference_type;
    //! Key type.
    typedef std::pair<const char*, size_t> key_type;
    //! Value type, key and value.
    typedef std::pair<key_type, T> value_type;
    ///@}

    //! Iterator to beginning of hash.
    iterator begin() const
    {
        return iterator(ib());
    }

    //! Iterator marking end of hash.
    iterator end() const
    {
        return iterator();
    }

    //! True iff hash is empty.
    bool empty() const
    {
        return size() == 0;
    }

    //! Number of elements in hash. O(1)
    size_type size() const
    {
        return ib_hash_size(ib());
    }

    //! Memory manager used by hash.
    MemoryManager memory_manager() const
    {
        return MemoryManager(ib_hash_pool(ib()));
    }

    /**
     * Fetch value from hash.
     *
     * @param[in] key        Key.
     * @param[in] key_length Length of @a key.
     *
     * @return Value.
     *
     * @throw enoent if no such key.
     **/
    T get(const char* key, size_t key_length) const
    {
        void* ib_value;
        T value;
        throw_if_error(ib_hash_get_ex(ib(), &ib_value, key, key_length));
        Internal::void_as_value<T>(
            value, ib_value,
            boost::is_pointer<T>()
        );
        return value;
    }

    /**
     * Fetch value from hash.
     *
     * @param[in] key Key.
     *
     * @return Value.
     *
     * @throw enoent if no such key.
     **/
    T get(const std::string& key) const
    {
        return get(key.data(), key.length());
    }

    /**
     * Fetch value from hash.
     *
     * @param[in] key Key.
     *
     * @return Value.
     *
     * @throw enoent if no such key.
     **/
    T get(ConstByteString key) const
    {
        return get(key.const_data(), key.length());
    }

    /**
     * Fetch value from hash.
     *
     * @param[in] key Key.
     *
     * @return Value.
     *
     * @throw enoent if no such key.
     *
     **/
    T operator[](const std::string& key) const
    {
        return get(key);
    }

    /**
     * Fetch value from hash.
     *
     * @param[in] key Key.
     *
     * @return Value.
     *
     * @throw enoent if no such key.
     **/
    T operator[](const ConstByteString key) const
    {
        return get(key);
    }

    /**
     * Fetch all values into a list.
     *
     * Consider using iterators instead.
     *
     * @param[in] list List to write values to.
     **/
    void get_all(List<T>& list) const
    {
        throw_if_error(ib_hash_get_all(ib(), list.ib()));
    }

private:
    ib_type m_ib;
};

/**
 * Hash; equivalent to a pointer to ib_hash_t.
 *
 * Hashs can be treated as ConstHashs.  See @ref ironbeepp for
 * details on IronBee++ object semantics.
 *
 * IronBee hashes are maps from byte sequence keys to generic pointers
 * (@c void*).  This template provides an interface to an IronBee hash that
 * assumes all values are the same actual type, @a T.
 *
 * @sa ironbeepp
 * @sa ib_hash_t
 * @sa ConstHash
 * @nosubgrouping
 **/
template <typename T>
class Hash :
    public ConstHash<T>
{
public:
    typedef ib_hash_t* ib_type;

    /**
     * Remove the constness of a ConstHash
     *
     * @warning This is as dangerous as a @c const_cast, use carefully.
     *
     * @param[in] hash ConstHash to remove const from.
     * @returns Hash pointing to same underlying hash as @a hash.
     **/
    static Hash remove_const(ConstHash<T> hash)
    {
        return Hash(const_cast<ib_type>(hash.ib()));
    }

    /**
     * Construct singular Hash.
     *
     * All behavior of a singular Hash is undefined except for
     * assignment, copying, comparison, and evaluate-as-bool.
     **/
    Hash() :
        m_ib(NULL)
    {
        // nop
    }

    /**
     * Key hashing function.
     *
     * Passed in key, key length, and a randomizer value that is consistent
     * for all calls for that hash.  Should return a hash value.
     **/
    typedef boost::function<
        uint32_t(const char*, size_t, uint32_t)
    > key_hash_t;

    /**
     * Key equality function.
     *
     * Passed in two keys by pointer and length.  Should return true iff they
     * are considered equal.  Equal keys should have the same hash value.
     **/
    typedef boost::function<
        bool(const char*, size_t, const char*, size_t)
    > key_equal_t;

    /**
     * Create new hash.  Case sensitive.
     *
     * Creates a new case sensitive hash.
     *
     * @param[in] memory_manager Memory manager to use.
     * @param[in] slots          Initial size of hash.
     * @return Empty Hash.
     **/
    static Hash create(MemoryManager memory_manager, size_t slots = 16)
    {
        ib_hash_t* h;
        throw_if_error(
            ib_hash_create_ex(
                &h, memory_manager.ib(), slots,
                &ib_hashfunc_djb2, NULL,
                &ib_hashequal_default, NULL
            )
        );
        return Hash(h);
    }

    /**
     * Create new hash.  Case insensitive.
     *
     * Creates a new case sensitive hash.
     *
     * @param[in] memory_manager Memory manager to use.
     * @param[in] slots          Initial size of hash.
     * @return Empty Hash.
     **/
    static Hash create_nocase(MemoryManager memory_manager, size_t slots = 16)
    {
        ib_hash_t* h;
        throw_if_error(
            ib_hash_create_ex(
                &h, memory_manager.ib(), slots,
                &ib_hashfunc_djb2_nocase, NULL,
                &ib_hashequal_nocase, NULL
            )
        );
        return Hash(h);
    }

    /**
     * Create new hash with custom hash and equal functions.
     *
     * @param[in] memory_manager Memory manager to use.
     * @param[in] slots          Initial size of hash.
     * @param[in] hash           Function to use to hash keys.
     * @param[in] equal          Function to use to compare keys.
     * @return Empty Hash.
     **/
    static
    Hash create(
        MemoryManager memory_manager,
        size_t        slots,
        key_hash_t    hash,
        key_equal_t   equal
    )
    {
        std::pair<ib_hash_function_t, void*> hash_trampoline;
        std::pair<ib_hash_equal_t, void*> equal_trampoline;
        ib_hash_t* h;

        hash_trampoline = make_c_trampoline<
            uint32_t(const char*, size_t, uint32_t)
        >(hash);
        equal_trampoline = make_c_trampoline<
            int(const char*, size_t, const char*, size_t)
        >(equal);

        memory_manager.register_cleanup(
            boost::bind(delete_c_trampoline, hash_trampoline.second)
        );
        memory_manager.register_cleanup(
            boost::bind(delete_c_trampoline, equal_trampoline.second)
        );
        throw_if_error(
            ib_hash_create_ex(
                &h, memory_manager.ib(), slots,
                hash_trampoline.first, hash_trampoline.second,
                equal_trampoline.first, equal_trampoline.second
            )
        );

        return Hash(h);
    }

    /**
     * @name C Interoperability
     * Methods to access underlying C types.
     **/
    ///@{

    //! ib_hash_t accessor.
    ib_type ib() const
    {
        return m_ib;
    }

    //! Construct Hash from ib_hash_t.
    explicit
    Hash(ib_type ib_hash) :
        ConstHash<T>(ib_hash),
        m_ib(ib_hash)
    {
        // nop
    }

    ///@}

    //! Clear hash.
    void clear() const
    {
        ib_hash_clear(ib());
    }

    /**
     * Set a value in hash.
     *
     * @param[in] key        Key.
     * @param[in] key_length Length of @a key.
     * @param[in] value      Value.
     **/
    void set(const char* key, size_t key_length, T value) const
    {
        throw_if_error(ib_hash_set_ex(
            ib(),
            key, key_length,
            Internal::value_as_void(value)
        ));
    }

   /**
    * Set a value in hash.
    *
    * @param[in] key   Key.
    * @param[in] value Value.
    **/
    void set(const std::string& key, T value) const
    {
        set(key.data(), key.length(), value);
    }

    /**
     * Set a value in hash.
     *
     * @param[in] key   Key.
     * @param[in] value Value.
     **/
    void set(ConstByteString key, T value) const
    {
        set(key.const_data(), key.length(), value);
    }

    /**
     * Remove a value from hash.
     *
     * @param[in] key        Key.
     * @param[in] key_length Length of @a key.
     *
     * @return Value removed.
     *
     * @throw enoent if no such key.
     **/
    T remove(const char* key, size_t key_length) const
    {
        void* ib_value;
        T value;
        throw_if_error(ib_hash_remove_ex(ib(), &ib_value, key, key_length));
        Internal::void_as_value<T>(
            value, ib_value,
            boost::is_pointer<T>()
        );
        return value;
    }

    /**
     * Remove a value from hash.
     *
     * @param[in] key Key.
     *
     * @return Value removed.
     *
     * @throw enoent if no such key.
     **/
    T remove(const std::string& key) const
    {
        return remove(key.data(), key.length());
    }

    /**
     * Remove a value from hash.
     *
     * @param[in] key Key.
     *
     * @return Value removed.
     *
     * @throw enoent if no such key.
     **/
    T remove(ConstByteString key) const
    {
        return remove(key.const_data(), key.length());
    }

private:
    ib_type m_ib;
};

} // IronBee

#endif
